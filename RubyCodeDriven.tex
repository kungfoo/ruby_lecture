%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%		Kommentar
%		Ein nettes old school template.......
%		last modified: 27/03/07
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4book,11pt,twoside]{scrbook}
\include{dude-template}

\begin{document}
\renewcommand{\theequation}{\thesection.\arabic}
\addtokomafont{caption}{\small}
\setkomafont{captionlabel}{\sffamily\bfseries}
\numberwithin{equation}{section}
\pagenumbering{Roman}
\setcapindent*{1em}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%		Titelseite
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\titlehead{
	\begin{minipage}{0.6\textwidth}{\IFSlogo[50mm]}
 	\end{minipage}
	\begin{minipage}{0.4\textwidth}
		\footnotesize \rightline{HSR Rapperswil} \rightline{Institut für Software}
	\end{minipage}
 } 

\author{Silvio Heuberger \\ Institut für Software}
\subject{Lecture Notes}
\title{Ruby, code-driven}
\date{FS 2009}
\publishers{}
\dedication{} 
\maketitle



\tableofcontents

\fontspec[Numbers={OldStyle}, Ligatures={Common}]{Adobe Garamond Pro}

\chapter{Ruby? Noch eine Sprache?} % (fold)
\label{cha:ruby_noch_eine_sprache_}

\pagenumbering{arabic}
\section{Was macht Ruby so speziell?} % (fold)
\label{sec:was_macht_ruby_so_speziell_}
Ruby ist eine spezielle Programmiersprache. Speziell für Programmierer, die sich statisch typisierte Sprachen wie Java, C\# und C++ gewöhnt sind. Folgende Punkte machen Ruby so speziell:

\subsection*{Ruby ist einfach zu lesen} % (fold)
\label{sub:ruby_ist_einfach_zu_lesen}

\includegraphics[width=\textwidth]{img/easy_to_read.png}

Lies folgenden Code laut vor:
\lstinputlisting{code/easytoread.rb}

Ruby ist »Coderspeak«, nicht nur eine Programmiersprache. Das obige Programm tut genau das, was erwartet wird, wenn man den Code vorliest.

Ein weiteres Beispiel ist folgender Code:
\lstinputlisting{code/easytoread2.rb}

Der Code beendet das Programm, ausser wenn der String »Restaurant« als Teil »aura« enthält, was auch der Fall ist. Ruby nutzt geschickte \emph{Konventionen}, was die Methodennamen angeht um die Lesbarkeit des Codes zu verbessern. Eine Methode, die am Ende des Names ein Fragezeichen hat, ist eine Ja/Nein-Frage an das Objekt auf dem sie aufgerufen wird (also eine Methode die einen \texttt{boolean} als Rückgabewert hat).

Das soll nicht heissen, dass Code der in einer anderen Sprache geschrieben ist schwer zu lesen ist. Vielfach ist das allerdings so und die Konventionen in Ruby machen viele Teile des Codes einfacher zu lesen und befreien ihn von Überraschungen. Mehr dazu im Kapitel \ref{cha:die_syntax_von_ruby}.
% subsection ruby_ist_einfach_zu_lesen (end)



\subsection*{Alles ist ein Objekt} % (fold)
\label{sub:alles_ist_ein_objekt}
In Ruby ist alles ein Objekt. Wirklich alles --- es gibt in Ruby keine Unterscheidung zwischen »primitiven Datentypen« und »benutzerdefinierten Typen«.
Nachfolgend ein paar Beispiele von Methoden, die auf Instanzen von Klassen aufgerufen werden. Nachgestellt als Kommentar ist jeweils das Resultat eines Statements.
\lstinputlisting{code/objects.rb}
% subsection alles_ist_ein_objekt (end)



\subsection*{Duck-Typing} % (fold)
\label{sub:duck_typing}
\begin{quotation}\swashed{»When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.« – James Whitcomb Riley}
\end{quotation}

Duck-Typing bedeutet dass erst zur Laufzeit überprüft wird, ob ein Objekt über bestimmte Merkmale — wie zum Beispiel Methodennamen und Attribute — verfügt, was zu einer erhöhten Flexibiltät führt. Es wird aber auch die Möglichkeit reduziert, Typen zur Compile-Zeit statisch zu prüfen und solche Fehler im Programm zu finden.

Ein längerer Abschnitt zu Duck-Typing findet sich später im Skript (siehe XXX). Hier einfach noch kurz ein Stück Code, das aufzeigt, wie flexibel und doch ausdrucksstark Code mit Duck-Typing werden kann. Über die Syntax mache man sich hier noch nicht allzu viele Gedanken...

\lstinputlisting{code/ducks.rb}

Folgendes gilt für obigen Code:
\begin{itemize}
	\item Vögel haben einen Namen.
	\item Enten sind auch Vögel, darum haben auch sie einen Namen.
	\item Enten haben eine Methode \texttt{quack()}, bei der sie ein entenartiges Geräusch von sich geben.
	\item Die Codezeile 17 iteriert über alle Vögel in \texttt{birds} und falls \texttt{bird.respond\_to? :quack} dann wird diese Methode aufgerufen. Andernfalls ist der Vogel keine Ente.
\end{itemize}

Die Ausgabe des Programms ist dann also:

\begin{lstlisting}
Gustav is not a duck!
Donald: quack!
\end{lstlisting}

Code wie der obige lässt sich mit \texttt{instanceof()} auch noch relativ kurz und prägnant in Java schreiben. Er wird aber schnell einiges komplizierter. Mehr dazu aber später.
% subsection duck_typing (end)



\subsection*{Noch viel mehr!} % (fold)
\label{sub:noch_viel_mehr_}
Dies ist nur ein ganz kleiner Ausschnitt, noch viel mehr macht Ruby zu einer speziellen, attraktiven Programmiersprache. Darauf wird aber erst in nachfolgenden Kapiteln eingegangen. Jetzt noch eine kurze Buzzword-Zusammenfassung, was Ruby so alles kann...
% subsection noch_viel_mehr_ (end)
% section was_macht_ruby_speziell (end)




\section{Woher kommt Ruby und was ist das Ziel} % (fold)
\label{sec:woher_kommt_ruby_und_was_ist_das_ziel}
Ruby wurde von Yukihiro »Matz« Matsumoto in Japan im Jahre 1995 zum ersten Mal released. Weltweit erreichte die Sprache danach den Ruf einer einfach zu erlernenden, mächtigen und expressiven Sprache.
Die Intention war damals ein »Perl, better than Perl« als Sprache zu entwerfen.

Folgende Kernpunkte sollten Ruby auszeichnen:
\begin{itemize}
	\item Pure OO-Sprache
	\item Simpel und frei von Überraschungen
	\item Mächtige und flexible Sprache
	\item Produktiv: Schnelle Entwicklung
	\item Nicht kommerziell: Ruby ist Open-Source
	\item Robust: Ruby hat einen Garbage-Collector
	\item Flexibel: Dynamisch typisierte Sprache
\end{itemize}
% section woher_kommt_ruby_und_was_ist_das_ziel (end)






% chapter ruby_noch_eine_sprache_ (end)

\chapter{Die Syntax von Ruby} % (fold)
\label{cha:die_syntax_von_ruby}
Die Syntax von Ruby ist kurz, prägnant und sprechend. Ruby wurde bewusst als »sprechbare« Sprache designt. Wenn eine Sprache der natürlichen Sprache ähnelt, so ist sie auch einfacher zu lesen und verstehen.
% chapter die_syntax_von_ruby (end)

\section{Variablen} % (fold)
\label{sub:variablen}
Variablennamen in Ruby bestehen aus Kleinbuchstaben, Zahlen und Underscores, dürfen aber nicht mit einer Zahl anfangen. Variablen können direkt einen Wert zugewiesen bekommen.

Normalerweise werden Variablennamen in Ruby nicht in CamelCase geschrieben, wie das in Java oder C der Fall ist, sondern mit Underscores zusammengehängt. Solche Style-Guidelines können aber zum Beispiel für ein gesamtes Projekt geändert werden, wobei man der Opensourcewelt eine Freude macht, wenn man sich daran hält...

Gültige Beispiele wären:
\lstinputlisting{code/variables.rb}
% section variablen (end)



\section{Zahlen} % (fold)
\label{sec:zahlen}
Die einfachsten Zahlen sind Ganzzahlen (\texttt{Integer}). Diese bestehen in Ruby aus einer beliebig langen Folge — richtig gelesen, Ruby hat automatischen Support für grosse Zahlen mit hunderten von Stellen — von Ziffern mit vorgestelltem Minus- oder Pluszeichen.

\lstinputlisting{code/integers.rb}
% section zahlen (end)


\section{Strings} % (fold)
\label{sec:strings}
Strings in Ruby kommen in verschiedenen Quote-Gewändern.
\begin{enumerate}
	\item Double-Quoted
	\item Single-Qouted
	\item General Delimited, dabei wird nach \% ein Character angegeben, mit dem der Anfang und das Ende des Strings markiert ist. Klammern sind auch möglich.
\end{enumerate}

Folgender Code illustiert das:
\lstinputlisting{code/strings.rb}

Diese Strings werden dann wie folgt ausgegeben (Code bis Zeile 8):
\begin{lstlisting}
Brief message to the user 
On a new line!
Single quotes too.\n Beware of the effect, though...
This is a "special" string. 'Lots' of quotes.
\end{lstlisting}
% section strings (end)

In Strings können auch mit der speziellen Zeichenfolge \#\{[Variable]\} Werte von Variablen eingesetzt werden. Das ergibt dann ab Zeile 8 folgenden Output:

\begin{lstlisting}
This article costs: 7.23$
\end{lstlisting}

\section{Symbols} % (fold)
\label{sec:symbols}
Symbols sind ein spezielles Element von Ruby, verglichen mit anderen Sprachen. Ein Symbol ist genau gleich wie ein Variablenname definiert, sie fangen aber mit \emph{einem Doppelpunkt} an.

Symbols sind \emph{leichtgewichtige} Strings. Das heisst, ein bestimmter Name für ein Symbol erzeugt immer das gleiche Symbol, egal wie oft es im Sourcecode vorkommt. Als Vergleich: Ein String-Literal (auch in Java) erzeugt \emph{immer} ein neues String-Objekt. Normalerweise verwendet man Symbols dort, wo ein String gebraucht wird, der aber nie auf dem Screen ausgegeben wird, wie zum Beispiel Namen von Methoden oder Hash-Elementen. (Siehe auch das Beispiel zu Duck-Typing)

\lstinputlisting{code/symbols.rb}
% section symbols (end)








\chapter*{Quellen} % (fold)
\label{cha:quellen}
Folgende Quellen lieferten Material für diese Lecture Notes:

\begin{itemize}
	\item »Why's (poignant) guide to ruby«\footnote{\url{http://poignantguide.net/ruby/}}: auflockernde Comics mit den Two Foxes.
\end{itemize}
% chapter quellen (end)

%\bibliography{FungiLit}                                                                                                                                                %\bibliographystyle{plain}                                                                                                                                                     %                         \nocite{*}%
%


\end{document}
